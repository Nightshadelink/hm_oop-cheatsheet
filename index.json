[{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/datentypen/","title":"Datentypen","tags":[],"description":"","content":" Type Art Wertebereich Operatoren int Ganze Zahlen (Integer) zwischen -2^31 und + (2^31)-1 + - * / % double Gleitkommazahlen Realezahlen + - * / boolean boolean Werte true oder false \u0026amp;\u0026amp; || ! char Zeichen abc\u0026hellip;z und Satzzeichen String Zeichenketten "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/deklaration_und_wertzuweisung/","title":"Deklaration und Wertzuweisung","tags":[],"description":"","content":"// Allgemein // \u0026lt;Datentyp\u0026gt; \u0026lt;Variablenname\u0026gt;; // Deklaration einfach int a; // Deklaration mehrfach int a,c; // Deklaration und gleichzeitge Wertzuweisung int a = 23; // Wertezuweisung a = 13212; // Deklaration und Zuweisung durch Berechnung int c = a + b; "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/vergleichsoperatoren/","title":"Vergleichsoperatoren","tags":[],"description":"","content":" Operator Bedeutung == gleich != ungleich \u0026lt; kleiner als \u0026gt; größer als \u0026lt;= kleiner gleich \u0026gt;= größer gleich "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/konsolenausgabe/","title":"Konsolenausgabe","tags":[],"description":"","content":"// Variablen Deklaration und Zuweisung String s = \u0026#34;Happy Hacking!\u0026#34; // einfache Ausgabe System.out.print(s); // Ausgabe mit Zeilenumbruch System.out.println(s); // Verknüpfung von Strings System.out.println(\u0026#34;Hallo Welt!\u0026#34; + s); // Leerzeile System.out.println(); "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/typenumwandlung-casting/","title":"Typenumwandlung (Casting)","tags":[],"description":"","content":"// Variablen Deklaration und Zuweisung String s = \u0026#34;Java 101\u0026#34; // Konvertierung in \u0026#34;Java 101\u0026#34; zu einem Ganzzahlenwert int Integer.parseInt(String s); // Konvertierung in \u0026#34;Java 101\u0026#34; zu einem Double-Wert double Double.parseDouble(s); // Konvertierung in \u0026#34;Java 101\u0026#34; zu einem Long-Wert long Long.parseLong(String s); "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/programmfluss_und_kontrollstrukturen/","title":"Programmfluss und Kontrollstrukturen","tags":[],"description":"","content":"Kontrollstruktur IF Statement\n// Wenn x größer als y ist, dann... if (x \u0026gt; y) { // ...führe den Code in dem Block aus } IF-ELSE STATEMENT\n// Wenn x größer als y ist, dann... if (x \u0026gt; y) { // ...führe den Code in dem Block aus }else{ // ... sonst führe diesen Block aus } Verschachtelte Bedingungen\n// Wenn x größer als y ist, dann... if (x \u0026gt; y) { // ...führe den Code in dem Block aus // wenn x gleich y ist... }else if(x == y){ // .. führe diesen Block aus }else{ // ... sonst führe diesen Block aus } SWITCH STATEMENT\nswitch (VARIABLE-ZUM-AUSWERTEN) { case value: Statement; break; ... ... ... default: Statement; break; } ANATOMY OF A LOOP STATEMENT FOR LOOP STATEMENT\nfor (zaehlvariable; Abbruchbedingung; Schrittweite){ // Code } Beispiel:\nZähle von 0 bis 10 in Einer-Schritten und gib die Zahl auf der Konsole aus:\nfor (int i = 0; i \u0026lt;= 10; i++) { System.out.println(i); } FOR-EACH STATEMENT\nfor(dataType item : array) { // code } Beispiel:\ngib alle Elemente aus dem Array numbers aus\n// array of numbers int[] numbers = {100, 200, 300, 400}; // for each loop for (int number: numbers) { System.out.println(number); } WHILE LOOP STATEMENT\nwhile(Abbruchbedingung){ // code } Beispiel:\nZähle von 0 bis 10 in Einer-Schritten und gib die Zahl auf der Konsole aus:\n// Zählvariable int i = 0; while (i \u0026lt;= 10){ System.out.println(i); i++; // i = i +1 ; } DO-WHILE LOOP STATEMENT\nFußgesteuert -\u0026gt; der Block wird immer mind. einmal ausgeführt.\ndo{ // code } while(Abbruchbedingung); Beispiel:\nZähle von 0 bis 10 in Einer-Schritten und gib die Zahl auf der Konsole aus:\nint i = 0; do{ System.out.println(i); i++; } while(i \u0026lt;= 10); "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/array/","title":"Array","tags":[],"description":"","content":"int[] ai; // array of int Object[] ao; // array of Object Beispiel: // Deklaration und Zuweisung int[] zahlen = { 1, 1, 2, 6, 24, 120, 720, 5040 }; String[] aas = { \u0026#34;array\u0026#34;, \u0026#34;of\u0026#34;, \u0026#34;String\u0026#34;, }; "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/zugriffsbeschraenkungen/","title":"Zugriffsbeschränkungen","tags":[],"description":"","content":" default (No keyword required) private public protected Die Standard-Sichtbarkeit ist \u0026ldquo;package-private\u0026rdquo; (obwohl diese nicht explizit verwendet werden kann), was bedeutet, dass das Feld innerhalb desselben Pakets, zu dem die Klasse gehört, zugänglich ist. Dies gilt jedoch nicht für Schnittstellenmitglieder, für die der Standardwert \u0026ldquo;public\u0026rdquo; ist.\nNON ACCESS MODIFIERS static final transient abstract synchronized volatile "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/abstraktion/","title":"Abstraktion","tags":[],"description":"","content":" Abstraktion versteckt Implementierungsdetails und gibt nur die Schnittstellen bekannt Erbende Klasse müssen diese Schnittstellen selbst implementieren Abstraktionen können sein: Abstract Class Interface Abstract Methods (in einer Klasse) Abstract Class Eine abstract class muss mit dem Schlüsselwort abstract deklariert werden Die Klasse kann abstract und non-abstract Methoden beinhalten Kann nicht Initialisiert werden Kann Konstruktoren und static Methoden beinhalten abstract class Blume{ // Abstrakte Methode \u0026#34;duft()\u0026#34; - muss dann von jeder Subklasse implementiert werden abstract String duft(); // nicht abstrakte Methode kann von jeder Subklasse genutzt werden public String pflanzen(){ System.out.println(\u0026#34;Ich werde gepflanzt\u0026#34;); } } public class Rose extends Blume{ // Implementierung der \u0026#34;duft()\u0026#34; Methode private String duft(){ System.out.println(\u0026#34;Rosen duften gut!\u0026#34;); } } Interface Interface ist a blueprint (Bauplan) einer class. Beinhaltet nur Abstrakte Methoden Beispiel:\n// Interface gibt die Methoden vor die Implementiert werden müssen interface Papier{ void drucken(); } // Sub-Klasse implementiert die Vorgaben public class A4 implements Papier{ public void drucken(){ System.out.println(\u0026#34;Seite wird gedruckt\u0026#34;); } } FAQ Was ist der Unterschied zwischen einer Abstract Class und einem Interface in Java In Java gibt es zwei Arten von abstrakten Typen: abstrakte Klassen und Interfaces. Der Unterschied besteht darin, dass:\nEine abstrakte Klasse Methoden und Felder enthalten kann, die bereits implementiert sind. Sie kann auch nicht-abstrakte Methoden enthalten. Eine abstrakte Klasse kann nicht instantiiert werden, aber sie kann von einer anderen Klasse erweitert werden. Ein Interface enthält nur Methodensignaturen und keine Implementierungen. Es kann keine Felder enthalten. Ein Interface kann von einer Klasse implementiert werden, aber es kann nicht erweitert werden. Ein anderer Unterschied ist, dass eine Klasse nur von einer abstrakten Klasse erben kann, aber mehrere Interfaces implementieren kann. Wann erkenne ich wann ich was verwenden soll? gibt es eine Eselsbrücke dafür? Es gibt keine feste Regel dafür, wann man eine abstrakte Klasse oder ein Interface verwenden sollte. Es hängt von der spezifischen Anforderung Ihres Projekts und der Art der Beziehungen zwischen den Klassen ab. Eine allgemeine Empfehlung ist jedoch:\nVerwenden Sie eine abstrakte Klasse, wenn Sie eine gemeinsame Basisklasse für mehrere Klassen haben, die bereits implementierte Methoden oder Felder enthält. Verwenden Sie ein Interface, wenn Sie sicherstellen möchten, dass bestimmte Methoden von bestimmten Klassen implementiert werden, ohne dass diese Klassen von einer gemeinsamen Basisklasse erben. Eine Eselsbrücke die man sich merken kann, um sich daran zu erinnern, wann man welches verwenden sollte: \u0026ldquo;abstrakt\u0026rdquo; für Abstraktion (gemeinsame Basis) \u0026ldquo;interface\u0026rdquo; für Implementierung (Verpflichtung zur Implementierung von Methoden) Es ist auch wichtig zu beachten, dass ab Java 8 Interfaces auch default Methoden haben können und somit auch bereits implementierte Methoden enthalten können. Du redest von nicht-abstrakten Methoden - was ist eine abstrakte Methode? Eine abstrakte Methode ist eine Methode, die in einer abstrakten Klasse oder einem Interface definiert wird, aber keine Implementierung hat. Sie hat nur eine Signatur, die beschreibt, welche Argumente die Methode erwartet und welchen Rückgabetyp sie hat. Eine abstrakte Methode muss in jeder nicht-abstrakten Unterklasse implementiert werden, die von der abstrakten Klasse erbt oder das Interface implementiert. Ein Beispiel für eine abstrakte Methode in Java wäre:\nabstract class Shape { abstract double getArea(); } In diesem Beispiel enthält die abstrakte Klasse Shape eine abstrakte Methode mit dem Namen \u0026ldquo;getArea\u0026rdquo;, die keine Implementierung hat. Jede nicht-abstrakte Unterklasse von Shape, wie z.B. Rectangle oder Circle, muss eine Implementierung für die Methode \u0026ldquo;getArea\u0026rdquo; bereitstellen. Es ist wichtig zu beachten, dass eine abstrakte Klasse mindestens eine abstrakte Methode enthalten muss, um als abstrakte Klasse zu gelten. Eine Klasse, die keine abstrakte Methode enthält, kann nicht als abstrakte Klasse deklariert werden.\nKann ein Interface instanziiert werden? Nein, ein Interface kann nicht instanziiert werden. Ein Interface ist ein abstrakter Typ, der nur Methodensignaturen enthält, aber keine Implementierungen. Es kann keine Objekte von einem Interface erstellt werden, da es keine konkrete Implementierung der Methoden hat. Eine Klasse, die ein Interface implementiert, muss die Methoden des Interfaces implementieren und kann dann instanziiert werden. Es gibt jedoch seit Java 8 die Möglichkeit, das Interface zu implementieren und zusätzlich einen default Methodenkörper zu haben, so dass man auf diesen Methoden aufrufen kann ohne das die Klasse selbst eine Implementierung besitzt. Ein Beispiel:\ninterface MyInterface { void myMethod(); default void myMethod2(){ System.out.println(\u0026#34;default implementation\u0026#34;); } } class MyClass implements MyInterface { public void myMethod() { // Implementation } } MyClass myObject = new MyClass(); myObject.myMethod(); myObject.myMethod2(); In diesem Beispiel kann man sehen, dass die Klasse MyClass das Interface MyInterface implementiert und dadurch die Methode myMethod() implementieren muss. myMethod2() kann aber ohne Implementierung in MyClass aufgerufen werden, da es einen default Methodenkörper besitzt.\n￼\nDann können folglich weder Interfaces, noch abstrakte Klassen instanziiert werden, oder? Das ist richtig, weder Interfaces noch abstrakte Klassen können direkt instanziiert werden. Eine abstrakte Klasse ist ein abstrakter Typ, der bereits implementierte Methoden und Felder enthalten kann, aber auch abstrakte Methoden besitzen kann. Da eine abstrakte Klasse nicht vollständig implementiert ist, kann sie nicht als Objekt verwendet werden. Eine nicht-abstrakte Unterklasse muss erstellt werden, die die abstrakten Methoden der abstrakten Klasse implementiert, bevor ein Objekt erstellt werden kann. Ein Interface ist ein abstrakter Typ, der nur Methodensignaturen enthält, aber keine Implementierungen. Eine Klasse, die ein Interface implementiert, muss die Methoden des Interfaces implementieren und kann dann instanziiert werden. Ein Interface selbst kann jedoch nicht instanziiert werden, da es keine Implementierungen der Methoden hat. Es ist auch wichtig zu beachten, dass ab Java 8 Interfaces auch default Methoden haben können. Diese Methoden besitzen bereits eine Implementierung, jedoch ist es nicht möglich ein Interface als Objekt zu instanzieren.\n￼\nWelche Konstellationen sind möglich - da war doch noch etwas in etwa \u0026#39;eine abstrakte Klasse/Interface kann nicht von einem solchen selbigen erben\u0026#39;, oder? Ja, das ist richtig. Eine abstrakte Klasse kann nicht von einer anderen abstrakten Klasse erben und ein Interface kann nicht von einem anderen Interface erben. Eine abstrakte Klasse kann jedoch von einem Interface erben und eine Klasse kann sowohl von einer abstrakten Klasse als auch von mehreren Interfaces erben. Hier sind einige mögliche Konstellationen:\nEine nicht-abstrakte Klasse kann von einer abstrakten Klasse erben und dabei die abstrakten Methoden der abstrakten Klasse implementieren. Eine nicht-abstrakte Klasse kann mehrere Interfaces implementieren und dabei die Methoden aller implementierten Interfaces implementieren. Eine abstrakte Klasse kann von einem Interface erben und dabei die Methoden des Interfaces implementieren. Eine nicht-abstrakte Klasse kann sowohl von einer abstrakten Klasse als auch von mehreren Interfaces erben und dabei die Methoden beider Typen implementieren. Es ist wichtig zu beachten, dass eine Klasse nur von einer einzigen Klasse erben kann, aber mehrere Interfaces implementieren kann. Es ist auch wichtig zu beachten, dass seit Java 8 Interfaces auch default Methoden enthalten können, so dass man diese Methoden aufrufen kann ohne das die Klasse selbst eine Implementierung besitzt. Es gibt auch die Möglichkeit, dass eine abstrakte Klasse mehrere Interfaces implementiert, in diesem Fall muss die abstrakte Klasse die Methoden aus allen implementierten Interfaces implementieren oder sie als abstrakt deklarieren. ￼\nWie könnte eine nicht-abstrakte Methode aussehen, welche von einer abstrakten Klasse und mehreren Interfaces erbt? Wenn eine nicht-abstrakte Klasse von einer abstrakten Klasse und mehreren Interfaces erbt, muss sie die Methoden der abstrakten Klasse und der Interfaces implementieren. Eine nicht-abstrakte Methode, die von einer abstrakten Klasse und mehreren Interfaces erbt, könnte in etwa so aussehen:\ninterface Interface1 { void interfaceMethod1(); } interface Interface2 { void interfaceMethod2(); } abstract class AbstractClass { abstract void abstractMethod(); } class ConcreteClass extends AbstractClass implements Interface1, Interface2 { public void abstractMethod() { // Implementation } public void interfaceMethod1() { // Implementation } public void interfaceMethod2() { // Implementation } } In diesem Beispiel erbt die Klasse ConcreteClass von der abstrakten Klasse AbstractClass und implementiert die Interfaces Interface1 und Interface2. Daher muss die Klasse ConcreteClass die Methoden abstractMethod, interfaceMethod1 und interfaceMethod2 implementieren. Es ist auch wichtig zu beachten, dass in diesem Beispiel, falls in eines der Interfaces default Methoden vorhanden sind, die Klasse ConcreteClass diese nicht implementieren muss. Sie kann diese Methoden direkt aufrufen und verwenden.\n￼\nUnd mit \u0026#39;default-Methoden\u0026#39; meist du solche Methoden, welche nicht nur Methodensignaturen, sondern auch Implementierungen sind, oder? Ja, das ist korrekt. \u0026ldquo;Default-Methoden\u0026rdquo; sind Methoden in Interfaces, die nicht nur Methodensignaturen, sondern auch eine Implementierung besitzen. Diese Methoden können direkt aufgerufen werden, ohne dass die implementierende Klasse eine eigene Implementierung bereitstellen muss. Seit Java 8 gibt es die Möglichkeit, default Methoden in Interfaces zu definieren. Diese Methoden werden mit dem Schlüsselwort \u0026ldquo;default\u0026rdquo; gekennzeichnet und haben einen Methodenkörper wie eine normale Methode. Diese default Methoden ermöglichen es, dass Interfaces bereits eine Implementierung besitzen und somit eine bestimmte Funktionalität bereitstellen können, ohne dass die implementierende Klasse diese selbst implementieren muss. Wenn eine Klasse ein Interface implementiert, das default Methoden enthält, kann sie diese Methoden direkt verwenden, ohne sie zu implementieren. Wenn die Klasse jedoch eine eigene Implementierung für eine default Methode bereitstellen möchte, kann sie dies tun, indem sie die default Methode mit dem Schlüsselwort \u0026ldquo;override\u0026rdquo; überschreibt. Es ist auch wichtig zu beachten, dass eine abstrakte Klasse, die ein Interface implementiert, die default Methoden des Interfaces entweder implementieren oder als abstrakt deklarieren muss.\n￼ Hier ist ein Beispiel, in dem eine abstrakte Klasse ein Interface implementiert, das default Methoden enthält:\ninterface MyInterface { void myMethod(); default void myDefaultMethod() { System.out.println(\u0026#34;default implementation\u0026#34;); } } abstract class MyAbstractClass implements MyInterface { public abstract void myMethod(); public void myDefaultMethod(){ //here the abstract class is providing an implementation for the default method } } class MyConcreteClass extends MyAbstractClass { public void myMethod() { // Implementation } } In diesem Beispiel implementiert die abstrakte Klasse MyAbstractClass das Interface MyInterface, das die default Methode myDefaultMethod() enthält. Da die abstrakte Klasse MyAbstractClass das Interface implementiert, muss sie die Methoden des Interfaces implementieren. In diesem Fall hat MyAbstractClass die default Methode myDefaultMethod implementiert und kann somit direkt aufgerufen werden. Es ist auch wichtig zu beachten, dass die nicht-abstrakte Unterklasse MyConcreteClass, die von MyAbstractClass erbt, die default Methode myDefaultMethod() nicht implementieren muss, da sie bereits von der abstrakten Klasse implementiert wurde. Es gibt auch die Möglichkeit, dass die abstrakte Klasse die default Methode als abstrakt deklariert und somit die nicht-abstrakte Unterklasse die Methode implementieren muss. Es gibt also mehrere Möglichkeiten, wie eine abstrakte Klasse mit default Methoden in Interfaces umgehen kann.\n"},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/account/","title":"Code - Account","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/bank/","title":"Code - Bank","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/carpetfactory/","title":"Code - Carpetfactory","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/chocolatebox/","title":"Code - ChocolateBox","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/cinema/","title":"Code - Cinema","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/copy_shop/","title":"Code - Copyshop","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/default_interfaces/","title":"Code - Default Interfaces","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/enum/","title":"Code - Enum","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/flights/","title":"Code - Flights","tags":[],"description":"","content":" Flight package src; public interface Flight { public int getDistance(); default public double getFinalPrice(FlightClass flightClass) { return getDistance() * flightClass.getPriceFactor(); } } Airport package src; import java.util.Objects; public class Airport { private final String name; public Airport(String name) { this.name = name; } public String getName() { return name; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Airport airport = (Airport) o; return Objects.equals(name, airport.name); } @Override public int hashCode() { return Objects.hash(name); } @Override public String toString() { return name; } } FlightClass package src; public enum FlightClass { ECONOMY(0.1), BUSINESS(0.2), FIRST(0.3); private final double priceFactor; FlightClass(double priceFactor) { this.priceFactor = priceFactor; } public double getPriceFactor() { return priceFactor; } } OneWayFlight package src; import java.util.Arrays; import java.util.List; public abstract class OneWayFlight implements Flight { protected final int distance; protected final Airport startAirport; protected final Airport endAirport; public OneWayFlight(int distance, Airport startAirport, Airport endAirport) { if (startAirport.equals(endAirport)) { throw new IllegalArgumentException(\u0026#34;Start and end airport must be different\u0026#34;); } this.distance = distance; this.startAirport = startAirport; this.endAirport = endAirport; } @Override public int getDistance() { return distance; } public Airport getStartAirport() { return startAirport; } public Airport getEndAirport() { return endAirport; } } class NonStopFlight extends OneWayFlight { public NonStopFlight(int distance, Airport startAirport, Airport endAirport) { super(distance, startAirport, endAirport); } } class StopOverFlight extends OneWayFlight { private final List\u0026lt;Airport\u0026gt; airports; public StopOverFlight(int distance, Airport startAirport, Airport endAirport, Airport... airports) { super(distance, startAirport, endAirport); this.airports = Arrays.asList(airports); } public List\u0026lt;Airport\u0026gt; getAirports() { return airports; } } OpenFlight package src; import java.util.Arrays; import java.util.List; public class OpenFlight implements Flight { private final List\u0026lt;OneWayFlight\u0026gt; flights; public OpenFlight(OneWayFlight... flights) { this.flights = Arrays.asList(flights); } @Override public int getDistance() { return flights.stream().mapToInt(OneWayFlight::getDistance).sum(); } public Airport getStartAirport() { return flights.get(0).getStartAirport(); } public Airport getEndAirport() { return flights.get(flights.size() - 1).getEndAirport(); } public List\u0026lt;OneWayFlight\u0026gt; getFlights() { return flights; } } class RoundTripFlight extends OpenFlight { public RoundTripFlight(OneWayFlight outbound, OneWayFlight returnFlight) { super(outbound, returnFlight); } } Main package src; public class Main { public static void main(String[] args) { new StopOverFlight(2050, new Airport(\u0026#34;München\u0026#34;), new Airport(\u0026#34;Paris\u0026#34;), new Airport(\u0026#34;New York\u0026#34;), new Airport(\u0026#34;Seattle\u0026#34;)); Airport munich = new Airport(\u0026#34;Munich\u0026#34;); Airport paris = new Airport(\u0026#34;Paris\u0026#34;); NonStopFlight nonStopFlight = new NonStopFlight(670, munich, paris); assert nonStopFlight.getDistance() == 670; assert nonStopFlight.getStartAirport().equals(munich); assert nonStopFlight.getEndAirport().equals(paris); } } "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/immutablerational/","title":"Code - Immutable Rational","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/inheritance/","title":"Code - Inheritance","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/intersection/","title":"Code - Intersection","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/pets/","title":"Code - Pets","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/points/","title":"Code - Points","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/rational/","title":"Code - Rational","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/shapes/","title":"Code - Shapes","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/sum/","title":"Code - Sum","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/time/","title":"Code - Time","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/codebucket/","title":"Codebuckets","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/credits/","title":"Credits","tags":[],"description":"","content":"Contributors Thanks to them for making Open Source Software a better place !\nAnd a special thanks to @vjeantet for his work on docdock, a fork of hugo-theme-learn. v2.0.0 of this theme is inspired by his work.\nPackages and libraries mermaid - generation of diagram and flowchart from text in a similar manner as markdown font awesome - the iconic font and CSS framework jQuery - The Write Less, Do More, JavaScript Library lunr - Lunr enables you to provide a great search experience without the need for external, server-side, search services\u0026hellip; horsey - Progressive and customizable autocomplete component clipboard.js - copy text to clipboard highlight.js - Javascript syntax highlighter modernizr - A JavaScript toolkit that allows web developers to use new CSS3 and HTML5 features while maintaining a fine level of control over browsers that don\u0026rsquo;t support Tooling Netlify - Continuous deployement and hosting of this documentation Hugo "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/instanzvariablen/","title":"Instanzvariablen","tags":[],"description":"","content":" Instanzvariablen sind nur innerhalb der Klasse sichtbar mit Hilfe von getter und setter können diese abgerufen oder verändert werden setter sind vom typ void und sollten als Argument den Datentyp der jeweiligen Instanzvariable haben getter geben den Datentyp zurück der Instanzvariable und sollten keine Argumente haben durch den this Operator kann man auf die Instanzvariablen direkt zugreifen Beispiel: Einfache Klasse:\npublic class Fahrzeug { private String name; } Beispiel Klasse mit getter und setter:\npublic class Fahrzeug { private String name; public void setName(String name){ this.name = name; } public String getName(){ return this.name; } } "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/klassendeklaration_mit_vererbung/","title":"Klassen Deklaration mit Vererbung","tags":[],"description":"","content":"class Auto extends Fahrzeug { private String nummernSchild; public void abs(){ // code } } Die Klasse Auto ist eine Unterklasse von der Klasse Fahrzeug (Spezialisierung) Die Klasse Auto übernimmt automatisch alle Funktionen und Attribute der Klasse Fahrzeug Die Klasse Auto kann die Funktionen der Klasse Fahrzeug erweitern und/oder überschreiben mit super können Methoden und Variablen der Basis-Klasse direkt aufgerufen werden dies gilt auch für den Konstruktor Konstruktoren Jede Klasse hat automatisch einen gleichnamigen Konstruktor dieser kann explizt sein (angegeben) oder implizit (nicht angegeben) sein Der Konstruktor wird automatisch beim Erstellen eines Objekt ausgeführt Konstruktoren haben keinen return Wert Beispiel:\npublic class Fahrzeug { private String name; // Konstruktor ohne Argumente public Fahrzeug(){ // code } // Konstruktor mit Argumenten public Fahrzeug(String name){ // code this.name = name; } } "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/klassendeklaration/","title":"Klassendeklaration","tags":[],"description":"","content":"class MyClass { // Instanzvariablen // Instanzmethoden } Beispiel:\npublic class Fahrzeug { private String name; public void fahr(){ // code } } "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/","title":"Konzept: OOP","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/methoden/","title":"Methoden","tags":[],"description":"","content":" Code wiederverwenden statt neuschreiben Testbarkeit erhöhen Lesbarkeit verbessern Allgemein\n\u0026lt;Sichtbarkeit\u0026gt; \u0026lt;Rückgabewert\u0026gt; \u0026lt;Methodenname\u0026gt;(\u0026lt;Parameter\u0026gt;){ // Code } Beispiel:\n// addition zweier Zahlen a und b public int sum (int a, int b) { // lokale variable int result; // Berechnung result = a + b; // Ergebnis zurückgeben return result; } Vereinfacht:\n// addition zweier Zahlen a und b public int sum (int a, int b) { // Ergebnis direkt zurückgeben return (a + b); } "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/object/","title":"Objekt","tags":[],"description":"","content":"// Deklaration einer Variable vom Objekt-Typ \u0026#34;String\u0026#34; String s; // Konstruktur aufrufen s = new String (\u0026#34;Hallo Welt\u0026#34;); // Klassenmethode ausführen die sich auf den Inhalt der Variable bezieht char c = s.chartAt(4); "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/","title":"OOP-Cheatsheet","tags":[],"description":"","content":"OOP-Cheatsheet In diesem Cheatsheet werden alle für die Prüfung relevanten Themen rund um OOP in Java zusammengefasst.\nEin Teil der Dokumentation ist selbst formuliert und nur an die Vorlesung angelehnt. Vorlesungsunerlagen und Beispiele hängen in den Static links mit an.\nBitte gerne um Vervollständigung!\n"},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/oop/polymorphismus/","title":"Polymorphismus","tags":[],"description":"","content":" Die Vielfältigkeit bei der Objekte in verschiedenen Situationen verschieden reagieren können Variante 1: Methodenüberladung Deklaration einer Methode mit verschiedenen übergabe Parametern je nachdem mit wie viel Parametern die Methode aufgerufen wird, verändert sie das Verhalten der Klasse public class Fahrzeug { private String name; // Methode ohne Argumente public faehrt(){ // code } // Methode mit Argumenten public faehrt(String Richtung){ // code } // Methode mit Argumenten public faehrt(String Richtung, int Geschwindigkeit){ // code } } Variante 2: Methodenüberschreibung Die Subklasse (Kindklasse) kann Methoden der Basisklasse (Eltern-Klasse) überschreiben Basis-Klasse Fahrzeug\npublic class Fahrzeug { private String name; // Methode ohne Argumente public faehrt(){ // code System.out.println(\u0026#34;Das Fahrzeug fährt\u0026#34;); } } Sub-Klasse erbt alle Funktionen und überschreibt die \u0026ldquo;faehrt\u0026rdquo; Methode\npublic class Auto implements Fahrzeug{ @Override public void faehrt(){ System.out.println(\u0026#34;Das Auto fährt\u0026#34;); } } Beispiel aufruf\n// Basis-Klasse // gibt \u0026#34;Das Fahrzeug fährt\u0026#34; auf der Konsole aus Fahrzeug fahrzeug = new Fahrzeug(); fahrzeug.faehrt(); // Sub-Klasse // gibt \u0026#34;Das Auto fährt\u0026#34; auf der Konsole aus Fahrzeug auto = new Auto(); auto.faehrt(); "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/showcase/","title":"Showcase","tags":[],"description":"","content":"TAT by OVH Tshark.dev by Ross Jacobs inteliver by Amir Lavasani "},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://nightshadelink.github.io/hm_oop-cheatsheet/vorlesungsthemen/","title":"Vorlesungsthemen","tags":[],"description":"","content":"Übersicht Einführung Objektorientierte Programmierung Attachments 01_einfuehrung_objektorientierte_programmierung.pdf (312 KB) Attachments 01_sum.java (569 B) Datentypen und Variablen Attachments 02_datentypen_und_variablen.pdf (459 KB) Objektorientierte Konzepte Attachments 03_objektorientierte_konzepte.pdf (212 KB) Objektvariablen Attachments 04_objektvariablen.pdf (128 KB) Attachments 04_account.zip (1 KB) Methoden und Konstruktoren Attachments 05_methoden_und_konstruktoren.pdf (164 KB) Attachments 05_rational.zip (1 KB) ArrayList Einführung / Testen mit JUnit 5 / Dokumentation mit Javadoc Attachments 06_arraylist.pdf (71 KB) 06_dokumentation_mit_javadoc.pdf (76 KB) 06_testen_mit_junit-5.pdf (121 KB) Statische Klassenelemente Attachments 07_statische_klassenelemente.pdf (165 KB) Attachments 07_enum_beispiele.zip (2 KB) 07_immutablerational.java (3 KB) UML und Interfaces Teil 1 Attachments 08_uml_und_interfaces_teil-1.pdf (152 KB) Attachments 08_copy_shop.zip (1 KB) 08_shapes.zip (1 KB) Teil 2 Attachments 09_uml_und_interfaces_teil-2.pdf (115 KB) Attachments 09_default_interface.zip (1 KB) Vererbung Attachments 10_Vererbung.pdf (300 KB) Attachments 10_inheritance2.zip (1 KB) 10_inheritance2_erweitert-um-abstract-und-redefinition.zip (1 KB) Die Klasse Object Attachments 11_Die Klasse Object.pdf (147 KB) "}]