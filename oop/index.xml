<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Konzept: OOP on Cheatsheet for OOP-Course</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/</link><description>Recent content in Konzept: OOP on Cheatsheet for OOP-Course</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><atom:link href="https://nightshadelink.github.io/hm_oop-cheatsheet/oop/index.xml" rel="self" type="application/rss+xml"/><item><title>Abstraktion</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/abstraktion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/abstraktion/</guid><description>Abstraktion versteckt Implementierungsdetails und gibt nur die Schnittstellen bekannt Erbende Klasse müssen diese Schnittstellen selbst implementieren Abstraktionen können sein: Abstract Class Interface Abstract Methods (in einer Klasse) Abstract Class Eine abstract class muss mit dem Schlüsselwort abstract deklariert werden Die Klasse kann abstract und non-abstract Methoden beinhalten Kann nicht Initialisiert werden Kann Konstruktoren und static Methoden beinhalten abstract class Blume{ // Abstrakte Methode &amp;#34;duft()&amp;#34; - muss dann von jeder Subklasse implementiert werden abstract String duft(); // nicht abstrakte Methode kann von jeder Subklasse genutzt werden public String pflanzen(){ System.</description></item><item><title>Instanzvariablen</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/instanzvariablen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/instanzvariablen/</guid><description>Instanzvariablen sind nur innerhalb der Klasse sichtbar mit Hilfe von getter und setter können diese abgerufen oder verändert werden setter sind vom typ void und sollten als Argument den Datentyp der jeweiligen Instanzvariable haben getter geben den Datentyp zurück der Instanzvariable und sollten keine Argumente haben durch den this Operator kann man auf die Instanzvariablen direkt zugreifen Beispiel: Einfache Klasse:
public class Fahrzeug { private String name; } Beispiel Klasse mit getter und setter:</description></item><item><title>Klassen Deklaration mit Vererbung</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/klassendeklaration_mit_vererbung/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/klassendeklaration_mit_vererbung/</guid><description>class Auto extends Fahrzeug { private String nummernSchild; public void abs(){ // code } } Die Klasse Auto ist eine Unterklasse von der Klasse Fahrzeug (Spezialisierung) Die Klasse Auto übernimmt automatisch alle Funktionen und Attribute der Klasse Fahrzeug Die Klasse Auto kann die Funktionen der Klasse Fahrzeug erweitern und/oder überschreiben mit super können Methoden und Variablen der Basis-Klasse direkt aufgerufen werden dies gilt auch für den Konstruktor Konstruktoren Jede Klasse hat automatisch einen gleichnamigen Konstruktor dieser kann explizt sein (angegeben) oder implizit (nicht angegeben) sein Der Konstruktor wird automatisch beim Erstellen eines Objekt ausgeführt Konstruktoren haben keinen return Wert Beispiel:</description></item><item><title>Klassendeklaration</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/klassendeklaration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/klassendeklaration/</guid><description>class MyClass { // Instanzvariablen // Instanzmethoden } Beispiel:
public class Fahrzeug { private String name; public void fahr(){ // code } }</description></item><item><title>Methoden</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/methoden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/methoden/</guid><description> Code wiederverwenden statt neuschreiben Testbarkeit erhöhen Lesbarkeit verbessern Allgemein
&amp;lt;Sichtbarkeit&amp;gt; &amp;lt;Rückgabewert&amp;gt; &amp;lt;Methodenname&amp;gt;(&amp;lt;Parameter&amp;gt;){ // Code } Beispiel:
// addition zweier Zahlen a und b public int sum (int a, int b) { // lokale variable int result; // Berechnung result = a + b; // Ergebnis zurückgeben return result; } Vereinfacht:
// addition zweier Zahlen a und b public int sum (int a, int b) { // Ergebnis direkt zurückgeben return (a + b); }</description></item><item><title>Objekt</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/object/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/object/</guid><description>// Deklaration einer Variable vom Objekt-Typ &amp;#34;String&amp;#34; String s; // Konstruktur aufrufen s = new String (&amp;#34;Hallo Welt&amp;#34;); // Klassenmethode ausführen die sich auf den Inhalt der Variable bezieht char c = s.chartAt(4);</description></item><item><title>Polymorphismus</title><link>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/polymorphismus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nightshadelink.github.io/hm_oop-cheatsheet/oop/polymorphismus/</guid><description>Die Vielfältigkeit bei der Objekte in verschiedenen Situationen verschieden reagieren können Variante 1: Methodenüberladung Deklaration einer Methode mit verschiedenen übergabe Parametern je nachdem mit wie viel Parametern die Methode aufgerufen wird, verändert sie das Verhalten der Klasse public class Fahrzeug { private String name; // Methode ohne Argumente public faehrt(){ // code } // Methode mit Argumenten public faehrt(String Richtung){ // code } // Methode mit Argumenten public faehrt(String Richtung, int Geschwindigkeit){ // code } } Variante 2: Methodenüberschreibung Die Subklasse (Kindklasse) kann Methoden der Basisklasse (Eltern-Klasse) überschreiben Basis-Klasse Fahrzeug</description></item></channel></rss>